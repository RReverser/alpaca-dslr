/*!
# <%= api.info.title %> <%= api.info.version %>

<%= api.info.description %>
*/

#![allow(unused_variables)]

use actix_web::{error::BlockingError, get, put, web::Path, App, HttpServer};
use serde::{Deserialize, Serialize};
use std::future::Future;
use tracing_actix_web::RootSpan;

mod common;
pub use common::*;

<%
const toTypeName = toPascalCase;

function toPropName(name) {
  let converted = toSnakeCase(name);
  if (converted === 'type') {
    converted += '_';
  }
  return converted;
}

function doc(description) {
  if (description) {
    return description.includes('\n') ? `/**\n${description}\n*/` : `/// ${description}`;
  }
}

function getRefTarget(ref) {
  return (refReplacements[ref.$ref] || ref).$ref;
}

function resolveRef(ref) {
  return refs.get(getRefTarget(ref));
}

function refToName(ref) {
  let $ref = getRefTarget(ref);
  assert.ok($ref, `Not a reference ${dbg(ref)}`);
  if ($ref.startsWith('#/components/schemas/Empty')) {
    return '()';
  }
  let match = $ref.match(/^#\/components\/(parameters|schemas|requestBodies|responses)\/(\w+)$/);
  assert.ok(match, `Invalid reference ${dbg(ref)}`);
  return `${toSnakeCase(match[1])}::${toTypeName(match[2])}`;
}

function handleType(schema) {
  if (schema.$ref) {
    return refToName(schema);
  }
  switch (schema.type) {
    case 'integer':
      switch (schema.format) {
        case 'uint32':
          return 'u32';
        case 'int32':
        case undefined: // assume that int32 is the default
          return 'i32';
      }
      break;
    case 'array':
      return `Vec<${handleType(schema.items)}>`;
    case 'number':
      return 'f64';
    case 'string':
      return 'String';
    case 'boolean':
      return 'bool';
  }
  console.warn(`Unhandled schema type`, schema);
  return '()';
}

function handleOptType(schema, required) {
  let type = handleType(schema);
  return required ? type : `Option<${type}>`;
}

function getTypeDescription(schema) {
  if ('description' in schema) {
    return schema.description;
  }
  if (schema.type === 'array') {
    return getTypeDescription(schema.items);
  }
  return '';
}
%>

<% function handleSchema(schemaName, schema) { %>
  <% schemaName = toTypeName(schemaName); %>
  <% if (schema.type === 'object') { %>
    pub struct <%= schemaName %> {
      <% for (let [propName, prop] of Object.entries(schema.properties)) { %>
        <%= doc(getTypeDescription(prop)) %>
        #[serde(rename = "<%= propName %>")]
        pub <%= toPropName(propName) %>: <%= handleOptType(prop, schema.required?.includes(propName)) %>,
      <% } %>
    }
  <% } else { %>
    #[repr(transparent)]
    pub struct <%= schemaName %>(<%= handleType(schema, schemaName, true) %>);
  <% } %>
<% } %>

mod schemas {
  use super::*;

  <% for (let [schemaName, schema] of Object.entries(api.components.schemas)) { %>
    <% if (schemaName.startsWith('Empty')) continue; %>
    <% if (schema['x-kind'] === 'Path' || schema['x-kind'] === 'Request') { %>
      #[derive(Deserialize)]
    <% } else { %>
      #[derive(Serialize)]
    <% } %>
    <%= handleSchema(schemaName, schema) %>
  <% } %>
}

<% for (let { path: pathUrl, method: methodName, id, operation: method } of ops()) { %>
  <%= doc(`${method.summary}${method.description && method.description !== method.summary ? `\n\n${method.description}` : ''}`) %>
  #[<%= methodName %>("<%= pathUrl %>")]
  fn <%= id %>(
    root_span: RootSpan,
    <% let pathRef = method['x-path'], pathRefName = refToName(pathRef); %>
    <% if (pathRefName !== '()') { %>
      path: Path<<%= pathRefName %>>,
    <% } %>
    <% let requestRef = method['x-request'], requestRefName = refToName(requestRef); %>
    request: ASCOMRequest<<%= requestRefName %>>
  ) -> impl Future<Output = Result<
    ASCOMResponse<<%= refToName(method.responses[200].content['application/json'].schema) %>>,
    BlockingError
  >> {
    <% if (pathRefName !== '()') { %>
      let <%= pathRefName %> {
        <% for (let param in resolveRef(pathRef).properties) { %>
          <%= toPropName(param) %>,
        <% } %>
      } = path.into_inner();
    <% } %>

    request.respond_with(root_span, move |<%= requestRefName %><% if (requestRefName !== '()') { %> {
      <% for (let param in resolveRef(requestRef).properties) { %>
        <%= toPropName(param) %>,
      <% } %>
    }<% } %>| {
      Err(ASCOMError::ACTION_NOT_IMPLEMENTED)
    })
  }

<% } %>

#[actix_web::main]
pub async fn main() -> std::io::Result<()> {
  HttpServer::new(|| {
    App::new()
    .wrap(tracing_actix_web::TracingLogger::<DomainRootSpanBuilder>::new())
    <% for (let { id } of ops()) { %>
      .service(<%= id %>)
    <% } %>
  })
  .bind(("127.0.0.1", 8080))?
  .run()
  .await
}
