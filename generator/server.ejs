/*!
# <%= api.info.title %> <%= api.info.version %>

<%= api.info.description %>
*/

use axum::{Router, routing::{get, post}};

pub struct TransactionResponse {
  client_transaction_id: u32,
  server_transaction_id: u32,
}

pub struct ASCOMError {
  code: i32,
  message: String,
}

#[derive(Serialize)]
pub struct ASCOMResponse<T> {
  #[serde(flatten)]
  transaction: TransactionResponse,
  #[serde(flatten)]
  result: std::result::Result<T, ASCOMError>,
}

impl<T: Serialize> IntoResponse for ASCOMResponse<T> {
  fn into_response(self) -> Response {
    Json(self).into_response()
  }
}

#[derive(Debug)]
pub enum AlpacaError {
  /// Method or parameter value error, check error message
  ValueError(String),

  // Server internal error, check error message
  InternalError(String),
}

impl IntoResponse for AlpacaError {
  fn into_response(self) -> Response {
    match self {
      Self::ValueError(message) => (StatusCode::BAD_REQUEST, message),
      Self::InternalError(message) => (StatusCode::INTERNAL_SERVER_ERROR, message),
    }.into_response()
  }
}

pub type Result<T> = std::result::Result<ASCOMResponse<T>, AlpacaError>;

<%
const toTypeName = toPascalCase;

function toPropName(name) {
  let converted = toSnakeCase(name);
  if (converted === 'type') {
    converted += '_';
  }
  return converted;
}

function doc(description) {
  if (description) {
    return `/**\n${description}\n*/`;
  }
}

function refToName(ref) {
  let match = ref?.$ref?.match(/^#\/components\/(parameters|schemas|requestBodies|responses)\/(\w+)$/);
  assert.ok(match, `Invalid reference ${dbg(ref)}`);
  return `${toSnakeCase(match[1])}::${toTypeName(match[2])}`;
}

function handleType(schema) {
  if (schema.$ref) {
    return refToName(schema);
  }
  switch (schema.type) {
    case 'integer':
      switch (schema.format) {
        case 'uint32':
          return 'u32';
        case 'int32':
        case undefined: // assume that int32 is the default
          return 'i32';
      }
      break;
    case 'array':
      return `Vec<${handleType(schema.items)}>`;
    case 'number':
      return 'f64';
    case 'string':
      return 'String';
    case 'boolean':
      return 'bool';
  }
  console.warn(`Unhandled schema type`, schema);
  return '()';
}

function handleOptType(schema, required) {
  let type = handleType(schema);
  return required ? type : `Option<${type}>`;
}

function getTypeDescription(schema) {
  if ('description' in schema) {
    return schema.description;
  }
  if (schema.type === 'array') {
    return getTypeDescription(schema.items);
  }
  return '';
}
%>

<% function handleSchema(schemaName, schema) { %>
  <% schemaName = toTypeName(schemaName); %>
  <% if (schema.type === 'object') { %>
    struct <%= schemaName %> {
      <% for (let [propName, prop] of Object.entries(schema.properties)) { %>
        <%= doc(getTypeDescription(prop)) %>
        #[serde(rename = "<%= propName %>")]
        <%= toPropName(propName) %>: <%= handleOptType(prop, schema.required?.includes(propName)) %>,
      <% } %>
    }
  <% } else { %>
    #[repr(transparent)]
    struct <%= schemaName %>(<%= handleType(schema, schemaName, true) %>);
  <% } %>
<% } %>

mod parameters {
  <% for (let [schemaName, {description, schema}] of Object.entries(api.components.parameters)) { %>
    <%= doc(description) %>
    #[derive(Deserialize)]
    <%= handleSchema(schemaName, schema) %>
  <% } %>
}

mod schemas {
  <% for (let [schemaName, schema] of Object.entries(api.components.schemas)) { %>
    <% if (schema['x-kind'] === 'Response') { %>
      #[derive(Serialize)]
    <% } else if (schema['x-kind']) { %>
      #[derive(Deserialize, FromRequest)]
      #[from_request(via(<%= schema['x-kind'] %>))]
    <% } else { %>
      #[derive(Deserialize)]
    <% } %>
    <%= handleSchema(schemaName, schema) %>
  <% } %>
}

<% for (let { path: pathUrl, method: methodName, id, operation: method } of ops()) { %>
  <%= doc(`${method.summary}${method.description && `\n\n${method.description}`}`) %>
  #[<%= methodName %>("<%= pathUrl.replaceAll(/\{(.*?)\}/g, '<$1>') %>")]
  fn <%= id %>(
    <% for (let ref of method['x-parameterSchemas']) { %>
      <%= refToName(ref) %> {
        <% for (let param in refs.get(ref.$ref).properties) { %>
          <%= toPropName(param) %>,
        <% } %>
      }: <%= refToName(ref) %>,
    <% } %>
  ) -> Result<<%= refToName(method.responses[200].content['application/json'].schema) %>> {

  }

<% } %>

#[actix_web::main]
async fn main() -> std::io::Result<()> {
  HttpServer::new(|| {
    App::new()
    <% for (let { id } of ops()) { %>
      .service(<%= id %>)
    <% } %>
  })
  .bind(("127.0.0.1", 8080))?
  .run()
  .await
}
