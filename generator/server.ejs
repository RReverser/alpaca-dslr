/*!
# <%= api.info.title %> <%= api.info.version %>

<%= api.info.description %>
*/

use axum::{Router, routing::{get, post}};

<% function doc(description) {
	if (description) {
		return `/**\n${description}\n*/`;
	}
} %>

<% function handleSchema(schemaName, schema) { %>
	struct <%= schemaName %>
	<% if (schema.type === 'object') { %>
		{
			<% for (let [propName, prop] of Object.entries(schema.properties)) { %>
				<%= doc(getTypeDescription(prop)) %>
				#[serde(rename = "<%= propName %>")]
				<%= toPropName(propName) %>: <%= handleType(prop) %>,
			<% } %>
		}
	<% } else { %>
		(<%= handleType(schema) %>);
	<% } %>
<% } %>

mod schemas {
	<% for (let [schemaName, schema] of Object.entries(api.components.schemas)) { %>
		#[derive(Serialize)]
		<%= handleSchema(schemaName, schema) %>
	<% } %>
}

<% for (let [pathUrl, path] of Object.entries(api.paths)) { %>
	<% for (let [methodName, method] of Object.entries(path)) { %>
		<%
			let fnName = `${methodName}_${path2id[pathUrl]}`;

			let groupedMethodParams = new Map();
			for (let param of method.parameters) {
				let groupName = toTypeName(param.in);
				let group = groupedMethodParams.get(groupName);
				if (!group) {
					group = [];
					groupedMethodParams.set(groupName, group);
				}
				group.push(param);
			}
		%>

		<% for (let [groupName, params] of groupedMethodParams) { %>
			#[derive(Deserialize, FromRequest)]
			#[from_request(via(<%= groupName %>))]
			struct <%= toTypeName(fnName) %><%= groupName %>Params {
				<% for (let param of params) { %>
					<%= doc(getTypeDescription(param)) %>
					#[serde(rename = "<%= param.name %>")]
					<%= toPropName(param.name) %>: <%= param.required ? '' : 'Option<' %><%= handleType(param.schema) %><%= param.required ? '' : '>' %>,
				<% } %>
			}
		<% } %>

		<%
			let methodBody = getRequestBody(method);
			if (methodBody) {
		%>
				#[derive(Deserialize, FromRequest)]
				#[from_request(via(<%= methodBody.type %>))]
				<%= handleSchema(toTypeName(fnName) + 'BodyParams', methodBody.schema) %>
		<%
				groupedMethodParams.set('Body', Object.keys(methodBody.schema.properties).map(name => ({ name })));
			}
		%>

		<%= doc(`${method.summary}${method.description && `\n\n${method.description}`}`) %>
		#[<%= methodName %>("<%= pathUrl.replaceAll(/\{(.*?)\}/g, '<$1>') %>")]
		fn <%= methodName %>_<%= path2id[pathUrl] %>(
			<% for (let [groupName, params] of groupedMethodParams) { %>
				<%= toTypeName(fnName) %><%= groupName %>Params {
					<% for (let param of params) { %>
						<%= toPropName(param.name) %>,
					<% } %>
				}: <%= toTypeName(fnName) %><%= groupName %>Params,
			<% } %>
		) {

		}
	<% } %>

<% } %>

#[actix_web::main]
async fn main() -> std::io::Result<()> {
	HttpServer::new(|| {
		App::new()
		<% for (let [pathUrl, path] of Object.entries(api.paths)) { %>
			<% for (let methodName in path) { %>
				.service(<%= methodName %>_<%= path2id[pathUrl] %>)
			<% } %>
		<% } %>
	})
	.bind(("127.0.0.1", 8080))?
	.run()
	.await
}
