/*!
# <%= api.info.title %> <%= api.info.version %>

<%= api.info.description %>
*/

use axum::{Router, routing::{get, post}};

#[derive(Deserialize)]
pub struct TransactionRequest {
  #[serde(rename = "ClientID")]
  client_id: Option<u32>,
  #[serde(rename = "ClientTransactionID")]
  client_transaction_id: Option<u32>,
}

#[derive(Serialize)]
pub struct TransactionResponse {
  #[serde(rename = "ClientTransactionID")]
  client_transaction_id: Option<u32>,
  #[serde(rename = "ServerTransactionID")]
  server_transaction_id: u32,
}

#[derive(Deserialize)]
pub struct ASCOMRequest<T> {
  #[serde(flatten)]
  transaction: TransactionRequest,
  #[serde(flatten)]
  request: T,
}

#[derive(Serialize)]
pub struct ASCOMError {
  code: i32,
  message: String,
}

#[derive(Serialize)]
pub struct ASCOMResponse<T> {
  #[serde(flatten)]
  transaction: TransactionResponse,
  #[serde(flatten)]
  result: std::result::Result<T, ASCOMError>,
}

impl<T: Serialize> IntoResponse for ASCOMResponse<T> {
  fn into_response(self) -> Response {
    Json(self).into_response()
  }
}

#[derive(Debug)]
pub enum AlpacaError {
  /// Method or parameter value error, check error message
  ValueError(String),

  // Server internal error, check error message
  InternalError(String),
}

impl IntoResponse for AlpacaError {
  fn into_response(self) -> Response {
    match self {
      Self::ValueError(message) => (StatusCode::BAD_REQUEST, message),
      Self::InternalError(message) => (StatusCode::INTERNAL_SERVER_ERROR, message),
    }.into_response()
  }
}

pub type Result<T> = std::result::Result<ASCOMResponse<T>, AlpacaError>;

<%
const toTypeName = toPascalCase;

function toPropName(name) {
  let converted = toSnakeCase(name);
  if (converted === 'type') {
    converted += '_';
  }
  return converted;
}

function doc(description) {
  if (description) {
    return description.includes('\n') ? `/**\n${description}\n*/` : `/// ${description}`;
  }
}

function getRefTarget(ref) {
  return (refReplacements[ref.$ref] || ref).$ref;
}

function resolveRef(ref) {
  return refs.get(getRefTarget(ref));
}

function refToName(ref) {
  let $ref = getRefTarget(ref);
  assert.ok($ref, `Not a reference ${dbg(ref)}`);
  if ($ref.startsWith('#/components/schemas/Empty')) {
    return '()';
  }
  let match = $ref.match(/^#\/components\/(parameters|schemas|requestBodies|responses)\/(\w+)$/);
  assert.ok(match, `Invalid reference ${dbg(ref)}`);
  return `${toSnakeCase(match[1])}::${toTypeName(match[2])}`;
}

function handleType(schema) {
  if (schema.$ref) {
    return refToName(schema);
  }
  switch (schema.type) {
    case 'integer':
      switch (schema.format) {
        case 'uint32':
          return 'u32';
        case 'int32':
        case undefined: // assume that int32 is the default
          return 'i32';
      }
      break;
    case 'array':
      return `Vec<${handleType(schema.items)}>`;
    case 'number':
      return 'f64';
    case 'string':
      return 'String';
    case 'boolean':
      return 'bool';
  }
  console.warn(`Unhandled schema type`, schema);
  return '()';
}

function handleOptType(schema, required) {
  let type = handleType(schema);
  return required ? type : `Option<${type}>`;
}

function getTypeDescription(schema) {
  if ('description' in schema) {
    return schema.description;
  }
  if (schema.type === 'array') {
    return getTypeDescription(schema.items);
  }
  return '';
}
%>

<% function handleSchema(schemaName, schema) { %>
  <% schemaName = toTypeName(schemaName); %>
  <% if (schema.type === 'object') { %>
    struct <%= schemaName %> {
      <% for (let [propName, prop] of Object.entries(schema.properties)) { %>
        <%= doc(getTypeDescription(prop)) %>
        #[serde(rename = "<%= propName %>")]
        pub <%= toPropName(propName) %>: <%= handleOptType(prop, schema.required?.includes(propName)) %>,
      <% } %>
    }
  <% } else { %>
    #[repr(transparent)]
    struct <%= schemaName %>(<%= handleType(schema, schemaName, true) %>);
  <% } %>
<% } %>

mod schemas {
  <% for (let [schemaName, schema] of Object.entries(api.components.schemas)) { %>
    <% if (schemaName.startsWith('Empty')) continue; %>
    <% if (schema['x-kind'] === 'Response') { %>
      #[derive(Serialize)]
    <% } else { %>
      #[derive(Deserialize)]
    <% } %>
    <%= handleSchema(schemaName, schema) %>
  <% } %>
}

<% for (let { path: pathUrl, method: methodName, id, operation: method } of ops()) { %>
  <%= doc(`${method.summary}${method.description && method.description !== method.summary ? `\n\n${method.description}` : ''}`) %>
  #[<%= methodName %>("<%= pathUrl.replaceAll(/\{(.*?)\}/g, '<$1>') %>")]
  fn <%= id %>(
    <%
      let { 'x-path': pathRef, 'x-request': requestRef, 'x-requestKind': requestKind } = method;
      let pathRefName = refToName(pathRef);
      let requestRefName = refToName(requestRef);
    %>
    <% if (pathRefName !== '()') { %>
      Path(<%= refToName(pathRef) %> {
        <% for (let param in resolveRef(pathRef).properties) { %>
          <%= toPropName(param) %>,
        <% } %>
      }): Path<<%= refToName(pathRef) %>>,
    <% } %>
    <%= requestKind %>(ASCOMRequest {
      transaction,
      request: <%= requestRefName %>
      <% if (requestRefName !== '()') { %>
        {
          <% for (let param in resolveRef(requestRef).properties) { %>
            <%= toPropName(param) %>,
          <% } %>
        }
      <% } %>,
    }): <%= requestKind %><ASCOMRequest<<%= requestRefName %>>>
  ) -> Result<<%= refToName(method.responses[200].content['application/json'].schema) %>> {

  }

<% } %>

#[actix_web::main]
async fn main() -> std::io::Result<()> {
  HttpServer::new(|| {
    App::new()
    <% for (let { id } of ops()) { %>
      .service(<%= id %>)
    <% } %>
  })
  .bind(("127.0.0.1", 8080))?
  .run()
  .await
}
