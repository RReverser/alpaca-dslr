/*!
# <%= api.info.title %> <%= api.info.version %>

<%= api.info.description %>
*/

#![allow(unused_variables, rustdoc::broken_intra_doc_links)]

use serde::{Deserialize, Serialize};

mod common;
pub use common::*;

<%
const toTypeName = toPascalCase;

const rustKeywords = new Set([
  "as",
  "use",
  "extern crate",
  "break",
  "const",
  "continue",
  "crate",
  "else",
  "if",
  "enum",
  "extern",
  "false",
  "fn",
  "for",
  "if",
  "impl",
  "in",
  "for",
  "let",
  "loop",
  "match",
  "mod",
  "move",
  "mut",
  "pub",
  "impl",
  "ref",
  "return",
  "Self",
  "self",
  "static",
  "struct",
  "super",
  "trait",
  "true",
  "type",
  "unsafe",
  "use",
  "where",
  "while",
  "abstract",
  "alignof",
  "become",
  "box",
  "do",
  "final",
  "macro",
  "offsetof",
  "override",
  "priv",
  "proc",
  "pure",
  "sizeof",
  "typeof",
  "unsized",
  "virtual",
  "yield"
]);

function toPropName(name) {
  name = toSnakeCase(name);
  if (rustKeywords.has(name)) {
    name = `r#${name}`;
  }
  return name;
}

function doc(description) {
  if (description) {
    return description.includes('\n') ? `/**\n${description}\n*/` : `/// ${description}`;
  }
}

function getRefTarget(ref) {
  return (refReplacements[ref.$ref] || ref).$ref;
}

function resolveRef(ref) {
  return refs.get(getRefTarget(ref));
}

function refToName(ref) {
  let $ref = getRefTarget(ref);
  assert.ok($ref, `Not a reference ${dbg(ref)}`);
  if ($ref.startsWith('#/components/schemas/Empty')) {
    return '()';
  }
  let match = $ref.match(/^#\/components\/(parameters|schemas|requestBodies|responses)\/(\w+)$/);
  assert.ok(match, `Invalid reference ${dbg(ref)}`);
  return `${toSnakeCase(match[1])}::${toTypeName(match[2])}`;
}

function handleType(schema) {
  if (schema.$ref) {
    return refToName(schema);
  }
  switch (schema.type) {
    case 'integer':
      switch (schema.format) {
        case 'uint32':
          return 'u32';
        case 'int32':
        case undefined: // assume that int32 is the default
          return 'i32';
      }
      break;
    case 'array':
      return `Vec<${handleType(schema.items)}>`;
    case 'number':
      return 'f64';
    case 'string':
      return 'String';
    case 'boolean':
      return 'bool';
  }
  console.warn(`Unhandled schema type`, schema);
  return '()';
}

function handleOptType(schema, required) {
  let type = handleType(schema);
  return required ? type : `Option<${type}>`;
}

function getTypeDescription(schema) {
  if ('description' in schema) {
    return schema.description;
  }
  if (schema.type === 'array') {
    return getTypeDescription(schema.items);
  }
  return '';
}
%>

mod schemas {
  use super::*;

  <% for (let [schemaName, schema] of Object.entries(api.components.schemas)) { %>
    <% if (schemaName.startsWith('Empty')) continue; %>
    <% schemaName = toTypeName(schemaName); %>
    #[derive(<%= schema['x-kind'] === 'Request' ? 'Deserialize' : 'Serialize' %>)]
    <% if (schema.type === 'object') { %>
      pub struct <%= schemaName %> {
        <% for (let [propName, prop] of Object.entries(schema.properties)) { %>
          <%= doc(getTypeDescription(prop)) %>
          #[serde(rename = "<%= propName %>")]
          pub <%= toPropName(propName) %>: <%= handleOptType(prop, schema.required?.includes(propName)) %>,
        <% } %>
      }
    <% } else { %>
      #[repr(transparent)]
      pub struct <%= schemaName %>(<%= handleType(schema, schemaName, true) %>);
    <% } %>
  <% } %>
}

rpc! {
  <% for (let [groupPath, { description, paths }] of Object.entries(groupedOps)) { %>
    <%= doc(description) %>
    #[http("<%= groupPath %>")]
    pub trait <%= toTypeName(groupPath) %> {
      <% for (let { subPath, method, operation, request, response } of paths) { %>
        <% let requestRefName = refToName(request); %>
        <%= doc(operation.description) %>
        #[http("<%= subPath %>")]
        fn <%= method === 'get' ? 'get' : 'set' %>_<%= subPath %>(
          &<%= method === 'get' ? '' : 'mut ' %>self<% if (requestRefName !== '()') { %>,
          request: <%= requestRefName %><% } %>
        ) -> ASCOMResult<<%= refToName(response) %>>;
      <% } %>
    }
  <% } %>
}

pub fn service() -> actix_web::Scope {
  actix_web::web::scope("/api/v1")
    <% for (let groupPath of Object.keys(groupedOps)) { %>
      .service(RpcService::<dyn <%= toTypeName(groupPath) %>>::default())
    <% } %>
}
