/*!
# <%= api.info.title %> <%= api.info.version %>

<%= api.info.description %>
*/

#![allow(unused_variables, rustdoc::broken_intra_doc_links)]

use serde::{Deserialize, Serialize};

mod common;
pub use common::*;

<%
const toTypeName = toPascalCase;

const rustKeywords = new Set([
  "as",
  "use",
  "extern crate",
  "break",
  "const",
  "continue",
  "crate",
  "else",
  "if",
  "enum",
  "extern",
  "false",
  "fn",
  "for",
  "if",
  "impl",
  "in",
  "for",
  "let",
  "loop",
  "match",
  "mod",
  "move",
  "mut",
  "pub",
  "impl",
  "ref",
  "return",
  "Self",
  "self",
  "static",
  "struct",
  "super",
  "trait",
  "true",
  "type",
  "unsafe",
  "use",
  "where",
  "while",
  "abstract",
  "alignof",
  "become",
  "box",
  "do",
  "final",
  "macro",
  "offsetof",
  "override",
  "priv",
  "proc",
  "pure",
  "sizeof",
  "typeof",
  "unsized",
  "virtual",
  "yield"
]);

function toPropName(name) {
  name = toSnakeCase(name);
  if (rustKeywords.has(name)) {
    name = `r#${name}`;
  }
  return name;
}

function doc(description) {
  if (description) {
    return description.includes('\n') ? `/**\n${description}\n*/` : `/// ${description}`;
  }
}

function handleType(schema) {
  let { $ref } = schema;
  if ($ref) {
    let replacement = refReplacements[$ref];
    if (replacement) {
      return handleType(replacement);
    }
    if ($ref === 'void') {
      return '()';
    }
    let match = $ref.match(/^#\/components\/(parameters|schemas|requestBodies|responses)\/(\w+)$/);
    assert.ok(match, `Invalid reference ${$ref}`);
    return `${toSnakeCase(match[1])}::${toTypeName(match[2])}`;
  }
  switch (schema.type) {
    case 'integer':
      switch (schema.format) {
        case 'uint32':
          return 'u32';
        case 'int32':
        case undefined: // assume that int32 is the default
          return 'i32';
      }
      break;
    case 'array':
      return `Vec<${handleType(schema.items)}>`;
    case 'number':
      return 'f64';
    case 'string':
      return 'String';
    case 'boolean':
      return 'bool';
  }
  console.warn(`Unhandled schema type`, schema);
  return '()';
}

function handleOptType(schema, required) {
  let type = handleType(schema);
  return required ? type : `Option<${type}>`;
}

function getTypeDescription(schema) {
  if ('description' in schema) {
    return schema.description;
  }
  if (schema.type === 'array') {
    return getTypeDescription(schema.items);
  }
  return '';
}
%>

mod schemas {
  use super::*;

  <% for (let [schemaName, schema] of Object.entries(api.components.schemas)) { %>
    <% if (schema['x-kind'] === 'Empty') continue; %>
    <% if (schema['x-kind'] === 'ValueResponse') { %>
      impl ToResponse for <%= handleType(schema.properties.Value) %> {
        type Response = ValueResponse<Self>;

        fn to_response(self) -> Self::Response {
          self.into()
        }
      }
    <% continue; } %>
    <% schemaName = toTypeName(schemaName); %>
    #[derive(<%= schema['x-kind'] === 'Request' ? 'Deserialize' : 'Serialize' %>)]
    <% if (schema.type === 'object') { %>
      pub struct <%= schemaName %> {
        <% for (let [propName, prop] of Object.entries(schema.properties)) { %>
          <%= doc(getTypeDescription(prop)) %>
          #[serde(rename = "<%= propName %>")]
          pub <%= toPropName(propName) %>: <%= handleOptType(prop, schema.required?.includes(propName)) %>,
        <% } %>
      }
    <% } else { %>
      #[repr(transparent)]
      pub struct <%= schemaName %>(<%= handleType(schema, schemaName, true) %>);
    <% } %>
    <% if (schema['x-kind'] === 'Response') { %>
      impl ToResponse for <%= schemaName %> {
        type Response = Self;

        fn to_response(self) -> Self::Response {
          self
        }
      }
    <% } %>
  <% } %>
}

rpc! {
  <% for (let [groupPath, { description, paths }] of Object.entries(groupedOps)) { %>
    <%= doc(description) %>
    #[http("<%= groupPath %>")]
    pub trait <%= toTypeName(groupPath) %> {
      <% for (let { subPath, method, operation, request, response } of paths) { %>
        <% request = handleType(request); %>
        <% response = handleType(response); %>
        <%= doc(operation.description) %>
        #[http("<%= subPath %>")]
        fn <%= method === 'get' ? 'get' : 'set' %>_<%= subPath %>(
          &<%= method === 'get' ? '' : 'mut ' %>self,
          <% if (request !== '()') { %>
          request: <%= request %>,
          <% } %>
        ) -> ASCOMResult<<%= response %>>;
      <% } %>
    }
  <% } %>
}

pub fn service() -> actix_web::Scope {
  actix_web::web::scope("/api/v1")
    <% for (let groupPath of Object.keys(groupedOps)) { %>
      .service(RpcService::<dyn <%= toTypeName(groupPath) %>>::default())
    <% } %>
}
