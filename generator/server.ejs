/*!
# <%= api.info.title %> <%= api.info.version %>

<%= api.info.description %>
*/

#![allow(rustdoc::broken_intra_doc_links)]

use super::*;

<%
function doc(description) {
  if (description) {
    return description.includes('\n') ? `/**\n${description}\n*/` : `/// ${description}`;
  }
}

function handleType(schema) {
  let { $ref } = schema;
  if ($ref) {
    let replacement = refReplacements[$ref];
    if (replacement) {
      return handleType(replacement);
    }
    if ($ref === 'void') {
      return '()';
    }
    let match = $ref.match(/^#\/components\/schemas\/(\w+)$/);
    assert.ok(match, `Invalid reference ${$ref}`);
    return `schemas::${toTypeName(match[1])}`;
  }
  switch (schema.type) {
    case 'integer':
      switch (schema.format) {
        case 'uint32':
          return 'u32';
        case 'int32':
        case undefined: // assume that int32 is the default
          return 'i32';
      }
      break;
    case 'array':
      return `Vec<${handleType(schema.items)}>`;
    case 'number':
      return 'f64';
    case 'string':
      return 'String';
    case 'boolean':
      return 'bool';
  }
  console.warn(`Unhandled schema type`, schema);
  return '()';
}

function handleOptType(schema, required) {
  let type = handleType(schema);
  return required ? type : `Option<${type}>`;
}

function getTypeDescription(schema) {
  if ('description' in schema) {
    return schema.description;
  }
  if (schema.type === 'array') {
    return getTypeDescription(schema.items);
  }
  return '';
}
%>

mod schemas {
  use super::*;

  <% for (let [schemaName, schema] of Object.entries(api.components.schemas)) { %>
    <% if (schema['x-kind'] === 'Empty' || schema['x-kind'] === 'ValueResponse') continue; %>
    <% schemaName = toTypeName(schemaName); %>
    <%= doc(schema.description) %>
    #[derive(<%= schema['x-kind'] === 'Request' ? 'Deserialize' : 'Serialize' %>)]
    <% if (schema.type === 'object') { %>
      pub struct <%= schemaName %> {
        <% for (let [propName, prop] of Object.entries(schema.properties)) { %>
          <%= doc(getTypeDescription(prop)) %>
          #[serde(rename = "<%= propName %>")]
          pub <%= toPropName(propName) %>: <%= handleOptType(prop, schema.required?.includes(propName)) %>,
        <% } %>
      }
    <% } else { %>
      #[repr(transparent)]
      pub struct <%= schemaName %>(<%= handleType(schema, schemaName, true) %>);
    <% } %>
  <% } %>
}

rpc! {
  <% for (let [groupPath, { description, paths, typeName }] of Object.entries(groupedOps)) { %>
    <%= doc(description) %>
    #[http("<%= groupPath %>")]
    pub trait <%= typeName %>
      <% if (typeName !== 'Device') { %>
        : Device
      <% } %>
    {
      <% for (let { subPath, method, fnName, operation, request, response } of paths) { %>
        <% request = handleType(request); %>
        <% response = handleType(response); %>
        <%= doc(operation.description) %>
        #[http("<%= subPath %>")]
        fn <%= fnName %>(
          &<%= method === 'get' ? '' : 'mut ' %>self,
          <% if (request !== '()') { %>
          request: <%= request %>,
          <% } %>
        )
        <% if (response !== '()') { %>
          -> <%= response %>
        <% } %>
        ;
      <% } %>
    }
  <% } %>
}
